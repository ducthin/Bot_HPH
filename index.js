const { Client, GatewayIntentBits, EmbedBuilder, ActivityType, Collection } = require('discord.js');
const { joinVoiceChannel, createAudioPlayer, createAudioResource, AudioPlayerStatus, VoiceConnectionStatus, NoSubscriberBehavior } = require('@discordjs/voice');
const youtubedl = require('youtube-dl-exec');
const yts = require('yt-search');
const fs = require('fs');
const path = require('path');
require('dotenv').config();

// Initialize Discord client
const client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.GuildVoiceStates,
        GatewayIntentBits.MessageContent
    ]
});

// Global variables
const queues = new Map();

// User Agents ƒë·ªÉ tr√°nh b·ªã ch·∫∑n
const USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:89.0) Gecko/20100101 Firefox/89.0'
];

// Utility functions
function getRandomUserAgent() {
    return USER_AGENTS[Math.floor(Math.random() * USER_AGENTS.length)];
}

async function retryWithDelay(fn, maxRetries = 3, delayMs = 2000) {
    for (let i = 0; i < maxRetries; i++) {
        try {
            return await fn();
        } catch (error) {
            console.log(`Th·ª≠ l·∫ßn ${i + 1}/${maxRetries} th·∫•t b·∫°i:`, error.message);
            if (i === maxRetries - 1) throw error;
            await new Promise(resolve => setTimeout(resolve, delayMs * (i + 1)));
        }
    }
}

function extractVideoID(url) {
    const regex = /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([^&\n?#]+)/;
    const match = url.match(regex);
    return match ? match[1] : null;
}

// Music functions
async function playSong(guildId, song) {
    const serverQueue = queues.get(guildId);
    
    if (!song) {
        console.log('H√†ng ƒë·ª£i tr·ªëng, bot s·∫Ω ·ªü l·∫°i voice channel...');
        // Kh√¥ng ng·∫Øt k·∫øt n·ªëi, ch·ªâ d·ª´ng player
        if (serverQueue && serverQueue.player) {
            serverQueue.player.stop();
        }
        return;
    }

    try {
        console.log('ƒêang th·ª≠ ph√°t b√†i h√°t:', song.title);
        console.log('URL b√†i h√°t:', song.url);
        
        let videoUrl = song.url;
        let videoId = extractVideoID(song.url);
        
        if (videoId) {
            const standardYoutubeUrl = `https://www.youtube.com/watch?v=${videoId}`;
            console.log('URL chu·∫©n h√≥a:', standardYoutubeUrl);
            
            try {
                console.log('ƒêang l·∫•y th√¥ng tin audio v·ªõi youtube-dl-exec...');
                
                // Get audio stream URL using youtube-dl-exec
                const audioInfo = await retryWithDelay(async () => {
                    return await youtubedl(standardYoutubeUrl, {
                        format: 'bestaudio',
                        extractAudio: true,
                        audioFormat: 'mp3',
                        getUrl: true,
                        userAgent: getRandomUserAgent(),
                        quiet: true
                    });
                }, 3, 3000);
                
                console.log('ƒê√£ l·∫•y audio URL th√†nh c√¥ng!');
                
                // Create audio resource
                const resource = createAudioResource(audioInfo, {
                    inputType: 'url',
                    inlineVolume: true
                });
                
                // Set volume
                if (resource.volume) {
                    resource.volume.setVolume(serverQueue.volume / 100);
                }
                
                // Play music
                serverQueue.player.play(resource);
                
                // Handle player events
                serverQueue.player.once(AudioPlayerStatus.Idle, () => {
                    console.log('B√†i h√°t ƒë√£ k·∫øt th√∫c, ph√°t b√†i ti·∫øp theo...');
                    serverQueue.songs.shift();
                    playSong(guildId, serverQueue.songs[0]);
                });
                
                serverQueue.player.once('error', (error) => {
                    console.error('L·ªói player:', error);
                    if (serverQueue.textChannel) {
                        serverQueue.textChannel.send('‚ùå L·ªói khi ph√°t nh·∫°c: ' + error.message);
                    }
                    serverQueue.songs.shift();
                    playSong(guildId, serverQueue.songs[0]);
                });
                
                // Send now playing message
                if (serverQueue.textChannel) {
                    const embed = new EmbedBuilder()
                        .setColor('#00ff00')
                        .setTitle('üéµ ƒêang ph√°t')
                        .setDescription(`**${song.title}**`)
                        .setThumbnail(song.thumbnail)
                        .addFields(
                            { name: '‚è±Ô∏è Th·ªùi l∆∞·ª£ng', value: song.duration, inline: true },
                            { name: 'üéß √Çm l∆∞·ª£ng', value: `${serverQueue.volume}%`, inline: true }
                        )
                        .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${song.requestedBy}` });
                    
                    serverQueue.textChannel.send({ embeds: [embed] });
                }
                
            } catch (streamError) {
                console.error('L·ªói stream:', streamError);
                if (serverQueue.textChannel) {
                    serverQueue.textChannel.send(`‚ùå Kh√¥ng th·ªÉ ph√°t b√†i h√°t: ${song.title}`);
                }
                serverQueue.songs.shift();
                playSong(guildId, serverQueue.songs[0]);
            }
        } else {
            throw new Error('Kh√¥ng th·ªÉ tr√≠ch xu·∫•t video ID t·ª´ URL');
        }
        
    } catch (error) {
        console.error('L·ªói trong playSong:', error);
        if (serverQueue.textChannel) {
            serverQueue.textChannel.send('‚ùå C√≥ l·ªói x·∫£y ra khi ph√°t nh·∫°c: ' + error.message);
        }
        serverQueue.songs.shift();
        playSong(guildId, serverQueue.songs[0]);
    }
}

// Discord event handlers
client.once('ready', () => {
    console.log('ü§ñ Happy House Bot ƒë√£ s·∫µn s√†ng!');
    console.log(`üéµ ƒê√£ ƒëƒÉng nh·∫≠p v·ªõi t√™n ${client.user.tag}`);
    
    client.user.setActivity('üéµ Music for Happy House', { type: ActivityType.Listening });
});

client.on('messageCreate', async (message) => {
    if (message.author.bot || !message.content.startsWith('!')) return;
    
    const args = message.content.slice(1).trim().split(/ +/);
    const command = args.shift().toLowerCase();
    
    if (command === 'play' || command === 'p') {
        if (!message.member.voice.channel) {
            return message.reply('‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc!');
        }
        
        if (!args.length) {
            return message.reply('‚ùå Vui l√≤ng nh·∫≠p t√™n b√†i h√°t ho·∫∑c URL YouTube!');
        }
        
        const query = args.join(' ');
        console.log('ƒê·∫ßu v√†o l√† t·ª´ kh√≥a t√¨m ki·∫øm:', query);
        
        try {
            let videoUrl = query;
            let videoInfo;
            
            // Check if input is YouTube URL
            if (query.includes('youtube.com') || query.includes('youtu.be')) {
                videoUrl = query;
                try {
                    const info = await youtubedl(videoUrl, { 
                        dumpJson: true,
                        quiet: true 
                    });
                    videoInfo = {
                        title: info.title,
                        url: videoUrl,
                        duration: info.duration ? Math.floor(info.duration / 60) + ':' + String(Math.floor(info.duration % 60)).padStart(2, '0') : 'N/A',
                        thumbnail: info.thumbnail || ''
                    };
                } catch (error) {
                    console.error('Error getting video info:', error);
                    return message.reply('‚ùå Kh√¥ng th·ªÉ l·∫•y th√¥ng tin video t·ª´ URL n√†y!');
                }
            } else {
                // Search YouTube
                const searchResults = await yts(query);
                if (!searchResults.videos.length) {
                    return message.reply('‚ùå Kh√¥ng t√¨m th·∫•y b√†i h√°t n√†o!');
                }
                
                const video = searchResults.videos[0];
                videoInfo = {
                    title: video.title,
                    url: video.url,
                    duration: video.duration.timestamp,
                    thumbnail: video.thumbnail
                };
            }
            
            const song = {
                title: videoInfo.title,
                url: videoInfo.url,
                duration: videoInfo.duration,
                thumbnail: videoInfo.thumbnail,
                requestedBy: message.author.username
            };
            
            // Get or create server queue
            let serverQueue = queues.get(message.guild.id);
            
            if (!serverQueue) {
                const connection = joinVoiceChannel({
                    channelId: message.member.voice.channel.id,
                    guildId: message.guild.id,
                    adapterCreator: message.guild.voiceAdapterCreator,
                });
                
                const player = createAudioPlayer({
                    behaviors: {
                        noSubscriber: NoSubscriberBehavior.Play,
                        maxMissedFrames: Math.round(5000 / 20),
                    },
                });
                
                connection.subscribe(player);
                
                serverQueue = {
                    textChannel: message.channel,
                    voiceChannel: message.member.voice.channel,
                    connection: connection,
                    player: player,
                    songs: [],
                    volume: 50,
                    playing: false
                };
                
                queues.set(message.guild.id, serverQueue);
                
                // Handle connection events
                connection.on(VoiceConnectionStatus.Ready, () => {
                    console.log('Voice connection ready!');
                });
                
                connection.on(VoiceConnectionStatus.Disconnected, () => {
                    console.log('Voice connection disconnected');
                });
                
                connection.on('error', (error) => {
                    console.error('Voice connection error:', error);
                });
            }
            
            serverQueue.songs.push(song);
            
            if (serverQueue.songs.length === 1) {
                console.log('Voice connection established, starting playback...');
                playSong(message.guild.id, song);
            } else {
                const embed = new EmbedBuilder()
                    .setColor('#ffff00')
                    .setTitle('üéµ ƒê√£ th√™m v√†o h√†ng ƒë·ª£i')
                    .setDescription(`**${song.title}**`)
                    .setThumbnail(song.thumbnail)
                    .addFields(
                        { name: '‚è±Ô∏è Th·ªùi l∆∞·ª£ng', value: song.duration, inline: true },
                        { name: 'üìù V·ªã tr√≠ trong h√†ng ƒë·ª£i', value: `${serverQueue.songs.length}`, inline: true }
                    )
                    .setFooter({ text: `Y√™u c·∫ßu b·ªüi ${song.requestedBy}` });
                
                message.channel.send({ embeds: [embed] });
            }
            
        } catch (error) {
            console.error('Error in play command:', error);
            message.reply('‚ùå C√≥ l·ªói x·∫£y ra khi x·ª≠ l√Ω y√™u c·∫ßu c·ªßa b·∫°n!');
        }
    }
    
    else if (command === 'skip' || command === 's') {
        const serverQueue = queues.get(message.guild.id);
        if (!serverQueue || !serverQueue.playing) {
            return message.reply('‚ùå Hi·ªán kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
        }
        
        serverQueue.player.stop();
        message.reply('‚è≠Ô∏è ƒê√£ b·ªè qua b√†i h√°t hi·ªán t·∫°i!');
    }
    
    else if (command === 'stop') {
        const serverQueue = queues.get(message.guild.id);
        if (!serverQueue) {
            return message.reply('‚ùå Hi·ªán kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
        }
        
        serverQueue.songs = [];
        serverQueue.player.stop();
        serverQueue.connection.destroy();
        queues.delete(message.guild.id);
        message.reply('‚èπÔ∏è ƒê√£ d·ª´ng ph√°t nh·∫°c v√† r·ªùi kh·ªèi voice channel!');
    }
    
    else if (command === 'queue' || command === 'q') {
        const serverQueue = queues.get(message.guild.id);
        if (!serverQueue || !serverQueue.songs.length) {
            return message.reply('‚ùå H√†ng ƒë·ª£i tr·ªëng!');
        }
        
        const embed = new EmbedBuilder()
            .setColor('#0099ff')
            .setTitle('üéµ H√†ng ƒë·ª£i nh·∫°c')
            .setDescription(
                serverQueue.songs.slice(0, 10).map((song, index) => 
                    `${index === 0 ? 'üéµ' : `${index}.`} **${song.title}** - ${song.duration}`
                ).join('\n')
            )
            .setFooter({ text: `T·ªïng: ${serverQueue.songs.length} b√†i h√°t` });
        
        message.channel.send({ embeds: [embed] });
    }
    
    else if (command === 'volume' || command === 'vol') {
        const serverQueue = queues.get(message.guild.id);
        if (!serverQueue) {
            return message.reply('‚ùå Hi·ªán kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t!');
        }
        
        if (!args[0]) {
            return message.reply(`üîä √Çm l∆∞·ª£ng hi·ªán t·∫°i: ${serverQueue.volume}%`);
        }
        
        const volume = parseInt(args[0]);
        if (isNaN(volume) || volume < 0 || volume > 100) {
            return message.reply('‚ùå √Çm l∆∞·ª£ng ph·∫£i t·ª´ 0 ƒë·∫øn 100!');
        }
        
        serverQueue.volume = volume;
        message.reply(`üîä ƒê√£ ƒë·∫∑t √¢m l∆∞·ª£ng th√†nh ${volume}%`);
    }
      else if (command === 'help' || command === 'h') {
        const embed = new EmbedBuilder()
            .setColor('#0099ff')
            .setTitle('ü§ñ Happy House Bot - H∆∞·ªõng d·∫´n')
            .addFields(
                { name: 'üéµ !play <t√™n b√†i h√°t/URL>', value: 'Ph√°t nh·∫°c t·ª´ YouTube', inline: false },
                { name: '‚è≠Ô∏è !skip', value: 'B·ªè qua b√†i h√°t hi·ªán t·∫°i', inline: false },
                { name: '‚èπÔ∏è !stop', value: 'D·ª´ng ph√°t nh·∫°c v√† r·ªùi voice', inline: false },
                { name: 'üëã !leave', value: 'R·ªùi kh·ªèi voice channel', inline: false },
                { name: 'üìù !queue', value: 'Xem h√†ng ƒë·ª£i nh·∫°c', inline: false },
                { name: 'üîä !volume <0-100>', value: 'ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng', inline: false },
                { name: '‚ùì !help', value: 'Hi·ªÉn th·ªã h∆∞·ªõng d·∫´n n√†y', inline: false }
            )
            .setFooter({ text: 'Happy House Bot - Music for everyone!' });
        
        message.channel.send({ embeds: [embed] });
    }
    
    else if (command === 'leave' || command === 'disconnect') {
        const serverQueue = queues.get(message.guild.id);
        if (!serverQueue) {
            return message.reply('‚ùå Bot kh√¥ng ·ªü trong voice channel n√†o!');
        }
        
        if (serverQueue.connection) {
            serverQueue.connection.destroy();
        }
        queues.delete(message.guild.id);
        message.reply('üëã ƒê√£ r·ªùi kh·ªèi voice channel!');
    }
});

// Error handling
process.on('unhandledRejection', error => {
    console.error('Unhandled promise rejection:', error);
});

process.on('uncaughtException', error => {
    console.error('Uncaught exception:', error);
});

// Login
console.log('ƒêang kh·ªüi ƒë·ªông Happy House Bot...');

if (!process.env.DISCORD_TOKEN) {
    console.error('‚ùå DISCORD_TOKEN kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y trong environment variables!');
    console.error('üí° H∆∞·ªõng d·∫´n:');
    console.error('1. T·∫°o file .env v·ªõi n·ªôi dung: DISCORD_TOKEN=your_token_here');
    console.error('2. Ho·∫∑c set environment variable DISCORD_TOKEN tr√™n platform deploy');
    console.error('3. Token l·∫•y t·ª´: https://discord.com/developers/applications');
    process.exit(1);
}

const token = process.env.DISCORD_TOKEN.trim();
if (!token.startsWith('MT') && !token.startsWith('MN')) {
    console.error('‚ùå Discord Token c√≥ format kh√¥ng ƒë√∫ng!');
    console.error('üí° Token ph·∫£i b·∫Øt ƒë·∫ßu b·∫±ng MT ho·∫∑c MN v√† d√†i kho·∫£ng 70+ k√Ω t·ª±');
    console.error('üîó L·∫•y token m·ªõi t·∫°i: https://discord.com/developers/applications');
    process.exit(1);
}

client.login(token)
    .then(() => console.log('‚úÖ ƒêƒÉng nh·∫≠p th√†nh c√¥ng!'))
    .catch(error => {
        console.error('‚ùå L·ªói khi ƒëƒÉng nh·∫≠p:', error);
        console.error('üí° Kh·∫Øc ph·ª•c:');
        console.error('1. Ki·ªÉm tra DISCORD_TOKEN c√≥ ƒë√∫ng kh√¥ng');
        console.error('2. Reset token t·∫°i Discord Developer Portal');
        console.error('3. C·∫≠p nh·∫≠t environment variable m·ªõi');
        process.exit(1);
    });
